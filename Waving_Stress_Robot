#include <Servo.h>

// ----------------- Pins -----------------
const byte SERVO_PIN = 7;   // keep servo OFF pins 9/10 to avoid Timer1 PWM conflicts
const byte TRIG      = 9;
const byte ECHO      = 10;

// ------------- Distance logic -----------
const unsigned PING_INTERVAL_MS = 60; // HC-SR04 min cycle time
unsigned long lastPingMs = 0;
float lastGoodCm = NAN;               // remember last valid reading

// ------------- Servo sweep logic --------
Servo myservo;

const float ACTIVATE_CM   = 20.0; // start sweeping at/under this
const float DEACTIVATE_CM = 23.0; // stop sweeping above this (hysteresis)

const int   MIN_ANG    = 0;
const int   MAX_ANG    = 180;
const int   STEP_DEG   = 10;
const uint16_t STEP_MS = 15;

int pos = MIN_ANG;
int dir = +1;                 // +1 up, -1 down
unsigned long lastStepMs = 0;
bool sweeping = false;        // current sweep state
bool servoIsAttached = false; // we attach only when needed

// Trigger the sensor at most every PING_INTERVAL_MS.
// Returns true if a NEW valid reading was captured and updates lastGoodCm.
bool updateDistance() {
  unsigned long now = millis();
  if (now - lastPingMs < PING_INTERVAL_MS) return false;

  lastPingMs = now;

  // Ensure a clean line before triggering (settle any leftover echo)
  pulseIn(ECHO, LOW, 30000UL);

  // Trigger pulse
  digitalWrite(TRIG, LOW);  delayMicroseconds(2);
  digitalWrite(TRIG, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG, LOW);

  // Measure echo (timeout ~25 ms -> ~4.3 m)
  unsigned long us = pulseIn(ECHO, HIGH, 25000UL);
  if (us == 0) return false; // no new valid reading this cycle

  lastGoodCm = us / 58.0;    // (us * 0.0343) / 2
  return true;
}

// Non-blocking sweep stepper
void stepSweep() {
  unsigned long now = millis();
  if (now - lastStepMs < STEP_MS) return;
  lastStepMs = now;

  pos += dir * STEP_DEG;
  if (pos >= MAX_ANG) { pos = MAX_ANG; dir = -1; }
  else if (pos <= MIN_ANG) { pos = MIN_ANG; dir = +1; }

  myservo.write(pos);
}

void setup() {
  Serial.begin(9600);
  pinMode(TRIG, OUTPUT);
  pinMode(ECHO, INPUT);
  digitalWrite(TRIG, LOW); // idle low

  // Start detached; we attach only when sweeping
  // myservo.attach(SERVO_PIN);
}

void loop() {
  // 1) Update distance at a safe rate
  bool gotNew = updateDistance();
  if (gotNew) {
    Serial.println(lastGoodCm, 1); // print only valid readings like "23.4"
  }

  // 2) Decide sweep state with hysteresis
  if (isfinite(lastGoodCm)) {
    if (!sweeping && lastGoodCm <= ACTIVATE_CM) sweeping = true;
    else if (sweeping && lastGoodCm > DEACTIVATE_CM) sweeping = false;
  }

  // 3) Drive servo according to state (non-blocking)
  if (sweeping) {
    if (!servoIsAttached) { myservo.attach(SERVO_PIN); servoIsAttached = true; }
    stepSweep();
  } else {
    if (servoIsAttached) { myservo.detach(); servoIsAttached = false; }
    // If you'd rather park at 0Â° instead of detaching:
    // if (!servoIsAttached) { myservo.attach(SERVO_PIN); myservo.write(MIN_ANG); myservo.detach(); }
  }
}
